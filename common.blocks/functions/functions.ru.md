# functions

Блок предоставляет объект, содержащий набор вспомогательных методов для работы с функциями JavaScript.

## Обзор

### Свойства и методы объекта

| Имя | Возвращаемое значение | Описание |
| -------- | --- | -------- |
| <a href="#fields-isFunction">isFunction</a>)(`obj` `{*}`) |  <code>{Boolean}</code> | Проверяет, является ли переданный аргументом объект функцией. |
| <a href="#fields-noop">noop()</a> | - | Заготовка пустой функции. |

### Элементы блока

| Элемент | Тип | Описание |
| --------| --------------------- | -------- |
| <a href="#elems-debounce">debounce</a> | Декоратор функции | Объединяет несколько вызовов функции, производимых в заданном временном интервале, в один. |
| <a href="#elems-throttle">throttle</a> | Декоратор функции | Функция выполняется не чаще одного раза в указанный период. |

### Публичные технологии блока

Блок реализован в технологиях:

* `vanilla.js`

## Подробности

<a name="fields"></a>
### Свойства и методы объекта

<a name="fields-isFunction"></a>
#### Метод `isFunction`

Метод проверяет, является ли переданный аргументом объект функцией.  

Принимаемые аргументы: 

* `obj` `{*}` – проверяемый объект. Обязательный аргумент.

Возвращаемое значение: `{Boolean}`. В случае, если аргумет является функцией – `true`.

```js
modules.require(['functions'], function(func) {
    var a = function(){},
        b = {};
    console.log(func.isFunction(a)); // true
    console.log(func.isFunction(b)); // false
});
```


<a name="fields-noop"></a>
#### Метод `noop`

Заготовка пустой функции (`function() {}`).

Не имеет аргументов и возвращаемого значения.

```js
modules.require(['functions'], function(func) {
    console.log(func.isFunction(func.noop)); // true
});
```


`noop` можно использовать в ситуациях, когда для работы требуется функция, но нет смысла добавлять логику. Например:
* для «прогрева» модулей. Если есть тяжелый модуль, которому для выполнения требуется время (например, для получения данных от файловой системы или бекенда), но результат его работы пока не нужен.

```js
modules.require(['functions'], function(func) {
    modules.require(['heavy'], func.noop);
    /* ... */ 
});
```


* в качестве «заглушки» для базовых классов при проектировании в парадигме ООП.

```js
modules.define('input', ['i-bem__dom', 'functions'], 
    function(provide, BEMDOM, func) {
        provide(BEMDOM.decl(this.name, {
            onSetMod: {
                js: {
                    inited: function() {
                        this.on('change', this._sendRequest);
                    }
                }
            },
            _sendRequest: func.noop,
            extraMethod: func.noop
    }));
});
```


<a name="elems"></a>
### Элементы блока

Элементы блока реализуют набор методов — декораторов функций.

Декораторы добавляют функции дополнительную логику, не изменяя ее. Сигнатуры оригинальной и декорированной функции полностью совпадают.

<a name="elems-debounce"></a>
#### Элемент `debounce`

Декоратор, позволяющий объединить несколько вызовов функции, произведенных в заданном временном интервале (далее **задержка**), в один. После каждой попытки вызова задержка начинает отсчитываться заново. 

В зависимости от значения аргумента `invokeAsap` `debounce` может работать в двух режимах:

1. Реальный вызов производится по истечению времени задержки после последней попытки вызова.
2. Реальный вызов производится сразу же при вызове декорированной функции. Последующие вызовы игнорируются, пока не истечет время задержки после последнего из них.

Принимаемые аргументы:

* `fn` `{Function}` — оригинальная функция. Обязательный аргумент.
* `timeout` `{Number}` — время задержки в миллисекундах. Обязательный аргумент.
* [`invokeAsap` `{Boolean}`] — режим работы `debounce`. По умолчанию используется первый режим (соответствует значению `false`).
* [`context` `{Object}`] — контекст для выполнения оригинальной функции.

Возвращаемое значение: `{Function}`. Декорированная функция.

Для примера рассмотрим форму, при вводе данных в которую, на сервер должен отправляться запрос. Посылать запросы при каждом нажатии клавиши пользователем – слишком затратно. Можно декорировать обработчик и запрос будет отправляться через 500 миллисекунд после того, как пользователь прекратил ввод:

```js
modules.define('input', ['i-bem__dom', 'functions__debounce'], 
    function(provide, BEMDOM, debounce) {
        provide(BEMDOM.decl(this.name, {
            onSetMod: {
                js: {
                    inited: function() {
                        this.on('change', debounce(this._sendRequest, 500));
                    }
                }
            },
            _sendRequest: function() { console.log('request'); }
    }));
});
```


<a name="elems-throttle"></a>
#### Элемент `throttle`

Декоратор позволяет «затормозить» функцию. Она будет выполняться не чаще одного раза в указанный период, сколько бы раз в течение этого периода ни была вызвана. Все промежуточные вызовы игнорируются.

Принимаемые аргументы:

* `fn` `{Function}` — оригинальная функция. Обязательный аргумент.
* `period` `{Number}` — интервал между вызовами в миллисекундах. Обязательный аргумент.
* [`context` `{Object}`] — контекст для выполнения оригинальной функции.

Возвращаемое значение: `{Function}`. Декорированная функция.

Метод удобно использовать, например, для установки ресурсоемких обработчиков для часто генерируемых событий – `resize`, `pointermove` и т.п.:

```js
modules.define('slowdown', ['i-bem__dom', 'functions__throttle'], 
    function(provide, BEMDOM, throttle) {
        provide(BEMDOM.decl(this.name, {
            onSetMod : {
                'js' : {
                    'inited' : function() { 
                        this.bindTo('pointermove', throttle(this._heavyLoad, 300)); 
                    }
                }
            },
            _heavyLoad : function() { console.log('message'); }
    }));
});
```

В результате, функция будет выполняться не чаще чем раз в 300 миллисекунд.
